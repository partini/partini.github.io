---
layout: default
footer_type: first
---
    <header class="masthead-services-1" style="background: linear-gradient(135deg,white 83%, blue 140%);">
        <div class="container">
            <div class="row services-1-firstrow">
                <div class="col-sm-12 col-md-12 col-lg-12 col-xl-12">
                    <p class="text-left" style="color: black;font-size: 33px;">Why we use NodeJs?</p>
                </div>
            </div>
            <div class="row services-1-secondrow">
                <div class="col-sm-12 col-md-12 col-lg-12 col-xl-12">
                    <p class="text-center text-sm-left text-md-left" style="font-weight: bold;font-size: 28px;">Get informed right now.</p>
                </div>
            </div>
            <div class="row services-1-thirdrow">
                <div class="col-sm-12 col-md-10 col-lg-10 col-xl-10 text-center">
                    <p class="text-left text-sm-left text-md-left text-lg-left text-xl-left">As an asynchronous event-driven JavaScript runtime, Node.js builds scalable network applications. In&nbsp;the following “hello world” example, many connections can be handled concurrently. Upon each&nbsp;connection, the callback is fired, but if there is no work to be done, Node.js will sleep.<br><br>Node.js is similar in design too. Influenced by systems like Ruby’s Event Machine and Python’s&nbsp;Twisted. Node.js takes the event model a bit further. It presents an event loop as a runtime construct&nbsp;instead of as a library.<br><br>In other systems, there is always a blocking call to start the event-loop. Typically, we define behavior&nbsp;through callbacks at the beginning of a script. At the end, a server starts through a blocking call like&nbsp;EventMachine::run().<br><br>In Node.js, there is no such start-the-event-loop call. Node.js simply enters the event loop after&nbsp;executing the input script. Node.js exits the event loop when there are no more callbacks to perform.&nbsp;<br>This behavior is like browser JavaScript — the event loop hides from the user.<br><br>HTTP is a first-class citizen in Node.js, with streaming and low latency. This makes Node.js well&nbsp;suited for the foundation of a web library or framework.<br><br>Node.js, designed without threads, doesn’t mean you can’t take advantage of multiple cores in your&nbsp;environment. Child processes can be spawned by using our child_process.fork() API. They are easy to&nbsp;communicate with. Cluster module allows you to share sockets between processes to enable load&nbsp;balancing over your cores.</p>
                </div>
            </div>
            <div class="row services-1-fourrow">
                <div class="col-12 col-sm-12 col-md-12 col-lg-12 col-xl-12 text-left" style="border-bottom: 1px solid;">
                  <a class="btn btn-light d-sm-inline d-md-inline d-lg-inline d-xl-inline" role="button">
                    <i class="fa fa-long-arrow-left"></i>
                  </a>
                    <p class="d-inline d-sm-inline d-md-inline d-lg-inline d-xl-inline">Technologies we use</p>
                </div>
            </div>
        </div>
    </header>
  </section> 
